(Задача 1)
Наша функція працює наступним чином:
Функція add використовує концепцію замикання (closure), щоб зберігати поточний стан суми та надавати можливість додавати нові числа. Вона повертає внутрішню функцію innerAdd, яка, в свою чергу, також повертає себе, доки не отримає undefined як наступний аргумент. Коли функція отримує undefined, вона повертає поточну суму.

(Задача 2)
Наша функція працює наступним чином:

1) Видаляємо пробіли з обох рядків та перетворюємо їх на нижній регістр, щоб уникнути впливу регістру символів.
2) Розбиваємо рядки на масиви окремих символів за допомогою split('').
3) Сортуємо отримані масиви символів за допомогою sort().
4) Об'єднуємо відсортовані масиви назад у рядки за допомогою join('').
5) Порівнюємо відсортовані рядки. Якщо вони однакові, то рядки є анаграмами, і функція повертає true. В іншому випадку повертається false.

(Задача 3)
Наша функція працює наступним чином:

1) Ми перевіряємо, чи переданий об'єкт obj є null або не є об'єктом. Якщо це так, повертаємо сам об'єкт без клонування.
2) Якщо obj є масивом, то ми створюємо новий масив clone і рекурсивно клонуємо кожен елемент масиву, викликаючи deepClone(obj[i]), і присвоюємо його відповідному індексу в clone.
3) Якщо obj є об'єктом, то ми створюємо новий об'єкт clone і рекурсивно клонуємо кожну властивість об'єкту, викликаючи deepClone(obj[key]), і присвоюємо його відповідному ключу в clone.
4) На кожному рівні рекурсії ми повертаємо клонований об'єкт clone.
5) У прикладі вище ми створюємо об'єкт originalObj, а потім глибоко клонуємо його, використовуючи функцію deepClone. Результат клонування зберігається у змінній clonedObj. Потім ми виводимо клонований об'єкт і перевіряємо, чи originalObj і clonedObj справді різні об'єкти.

(Задача 4)
Наша функція працює наступним чином:
1) Наша функція cacheWrapper приймає функцію fn в якості параметра. Вона створює об'єкт cache, що слугує як кеш для результатів.
2) При кожному виклику функції, обгортка перевіряє, чи є результат збережений в кеші для даного набору аргументів (key). Якщо так, результат повертається без обчислення, і виводиться повідомлення про отримання результату з кешу.
3) Якщо результат не знайдений в кеші, функція fn викликається з переданими аргументами (...args), результат зберігається в кеші за ключем key, і виводиться повідомлення про обчислення результату.
4) У прикладі вище ми створюємо функцію add, яка додає три числа. Потім ми створюємо обгортку cachedCalc за допомогою cacheWrapper, передаючи функцію add. При кожному виклику cachedCalc з різними аргументами, функція перевіряє кеш і повертає результат з кешу або обчислює та кешує новий результат.
5) У першому виклику cachedCalc(2, 2, 3) результат обчислюється і виводиться повідомлення "Calculated: 7". У другому виклику cachedCalc(5, 8, 1) так само обчислюється і виводиться повідомлення "Calculated: 14". А у третьому виклику cachedCalc(2, 2, 3) результат отримується з кешу і виводиться повідомлення "Retrieved from cache: 7".


